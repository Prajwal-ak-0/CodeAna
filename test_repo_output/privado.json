{
  "RepoConfigMetaData" : [
  ],
  "monolithJsonPath" : [
  ],
  "language" : "python",
  "privadoLanguageEngineVersion" : "0.1.18",
  "privadoMainVersion" : "1.3.75\n",
  "gitMetadata" : {
    "branchName" : "main",
    "commitId" : "440238963f857bfdff1f917ca98d588862d4f822",
    "remoteUrl" : ""
  },
  "violations" : [
  ],
  "PropertyFileSkippedByDirCount" : {
    "currentFilesInDirLimit" : "10",
    "skipList" : [
    ]
  },
  "androidPermissions" : [
  ],
  "privadoCoreVersion" : "1.1.206",
  "sinks" : [
    {
      "sourceType" : "Sinks",
      "sinkType" : "third_parties",
      "id" : "ThirdParties.SDK.OpenAI",
      "name" : "OpenAI",
      "domains" : [
        "openai.com"
      ],
      "apiUrl" : [
      ],
      "databaseDetails" : {
        "dbName" : "",
        "dbVendor" : "",
        "dbLocation" : "",
        "dbOperation" : "",
        "configFile" : "",
        "schema" : null
      }
    },
    {
      "sourceType" : "Sinks",
      "sinkType" : "storages",
      "id" : "Storages.Android.SQLite.ReadAndWrite",
      "name" : "SQLite",
      "domains" : [
        "sqlite.org"
      ],
      "apiUrl" : [
      ],
      "databaseDetails" : {
        "dbName" : "",
        "dbVendor" : "",
        "dbLocation" : "",
        "dbOperation" : "",
        "configFile" : "",
        "schema" : null
      }
    }
  ],
  "privadoCLIVersion" : "dev",
  "collections" : [
  ],
  "repoName" : "test_repo",
  "processing" : [
  ],
  "dataFlow" : {
    "storages" : [
    ],
    "internal_apis" : [
    ],
    "leakages" : [
    ],
    "third_parties" : [
    ]
  },
  "probableSinks" : [
    "dotenv.py",
    "openai.py",
    "typing.List.__iter__",
    "typing.List.__iter__.<returnValue>.__next__",
    "typing.List.extend",
    "typing.List.__iter__.<returnValue>.__next__.<returnValue>",
    "chunking.py",
    "sqlite3.py",
    "numpy.py",
    "async_client.embeddings.<returnValue>.<member>(embeddings).create",
    "typing.Dict.items",
    "typing.Dict.items.<returnValue>.__iter__",
    "typing.Dict.items.<returnValue>.__iter__.__next__",
    "typing.Dict.get",
    "database_handler.py",
    "csv_writer.py"
  ],
  "createdAt" : 1740997725245,
  "sinkProcessing" : [
    {
      "sinkId" : "ThirdParties.SDK.OpenAI",
      "occurrences" : [
        {
          "sample" : "AsyncOpenAI(api_key = os.getenv(\"OPENAI_API_KEY\"), timeout = 60.0, max_retries = 3)",
          "lineNumber" : 52,
          "columnNumber" : 29,
          "fileName" : "sqlite_rag.py",
          "excerpt" : "        load_dotenv()\n        self.db_path = db_path\n        # self._init_db()\n        self.db_handler = DatabaseHandler(db_path)\n        self.db_handler._init_db()\n        self.async_client = AsyncOpenAI( /* <=== openai.py */ \n            api_key=os.getenv(\"OPENAI_API_KEY\"),\n            timeout=60.0,\n            max_retries=3\n        )\n",
          "arguments" : null
        },
        {
          "sample" : "tmp2.create(input = texts, model = self.model)",
          "lineNumber" : 20,
          "columnNumber" : 30,
          "fileName" : "batch_embedding.py",
          "excerpt" : "        self.batch_size = batch_size\n\n    async def embed_batch(self, batch: List[Dict]) -> List[Dict]:\n        texts = [chunk[\"text\"] for chunk in batch]\n        try:\n            response = await self.client.embeddings.create( /* <=== openai.py */ \n                input=texts,\n                model=self.model\n            )\n            return [\n                {",
          "arguments" : null
        }
      ]
    },
    {
      "sinkId" : "Storages.Android.SQLite.ReadAndWrite",
      "occurrences" : [
        {
          "sample" : "conn.cursor()",
          "lineNumber" : 303,
          "columnNumber" : 9,
          "fileName" : "sqlite_rag.py",
          "excerpt" : "    # Initialize the RAG system\n    rag_system = SQLiteOpenAIRAG()\n    \n    # Check if we need to store new documents\n    conn = sqlite3.connect(rag_system.db_path)\n    c = conn.cursor() /* <=== sqlite3.py */ \n    c.execute('SELECT COUNT(*) FROM document_chunks')\n    count = c.fetchone()[0]\n    conn.close()\n    \n    if count == 0 and chunked_docs:",
          "arguments" : null
        },
        {
          "sample" : "c.fetchall()",
          "lineNumber" : 79,
          "columnNumber" : 22,
          "fileName" : "database/database_handler.py",
          "excerpt" : "        # Retrieve all chunks and their embeddings\n        try:\n            conn = sqlite3.connect(self.db_path)\n            c = conn.cursor()\n            c.execute('SELECT chunk, page_number, embedding FROM document_chunks')\n            chunks = c.fetchall() /* <=== sqlite3.py */ \n            conn.close()\n        except Exception as e:\n            print(f\"Error retrieving chunks from database: {str(e)}\")\n            return []\n",
          "arguments" : null
        }
      ]
    }
  ],
  "PropertyFileSkippedBySize" : {
    "currentFileSizeLimit" : "5",
    "skipLists" : [
    ]
  },
  "localScanPath" : "/home/prajwalak/Desktop/test_repo",
  "sources" : [
  ]
}