{
    "name": "root",
    "children": [
        {
            "name": "batch_embedding.py",
            "structure": {
                "classes": [
                    {
                        "name": "AsyncEmbeddingGenerator",
                        "class_body": "│class AsyncEmbeddingGenerator:\n",
                        "methods": [
                            {
                                "name": "__init__",
                                "code": "│    def __init__(self, model: str = \n\"text-embedding-3-small\", batch_size: int = 15):\n│        self.client = \nAsyncOpenAI(api_key=os.getenv(\"OPENAI_API_KEY\"))\n│        self.model = model\n⋮...\n│    async def embed_batch(self, batch: List[Dict]) -> \nList[Dict]:\n⋮...\n│    async def embed_chunks(self, chunked_document: \nList[Dict]) -> List[Dict]:\n⋮...\n│async def main():\n⋮...\n"
                            }
                        ]
                    }
                ],
                "other": "⋮..."
            },
            "source": [],
            "data_model": [],
            "third_party_dependencies": [],
            "sink_details": [
                {
                    "ai_sink_label": "API for OpenAI",
                    "code_summary": "The code snippet is making a call to the OpenAI API to create embeddings from the provided texts using a specified model.",
                    "code_snippet": "tmp2.create(input = texts, model = self.model)",
                    "line_number": "20",
                    "column_number": "30"
                }
            ],
            "vulnerabilities": []
        },
        {
            "name": "database",
            "children": [
                {
                    "name": "database_handler.py",
                    "structure": {
                        "classes": [
                            {
                                "name": "DatabaseHandler",
                                "class_body": "│class DatabaseHandler:\n",
                                "methods": [
                                    {
                                        "name": "__init__",
                                        "code": "│    def __init__(self, db_path: str):\n│        self.db_path = db_path\n⋮...\n"
                                    },
                                    {
                                        "name": "_init_db",
                                        "code": "│    def _init_db(self):\n⋮...\n"
                                    },
                                    {
                                        "name": "store_chunked_docs",
                                        "code": "│    def store_chunked_docs(self, chunked_docs: \nList[Dict]) -> None:\n⋮...\n"
                                    },
                                    {
                                        "name": "_cosine_similarity",
                                        "code": "│    def _cosine_similarity(self, query_embedding: \nList[float], doc_embedding: np.ndarray) -> float:\n⋮...\n│    async def get_relevant_chunks(self, query: str, k:\nint = 3, async_client=None) -> List[Dict]:\n⋮...\n"
                                    }
                                ]
                            }
                        ],
                        "other": "⋮..."
                    },
                    "source": [],
                    "data_model": [],
                    "third_party_dependencies": [],
                    "sink_details": [
                        {
                            "ai_sink_label": "SQLite",
                            "code_summary": "The code snippet retrieves all rows from the executed SQL command using the 'fetchall()' method on a SQLite database cursor, indicating that it is reading data from the SQLite database.",
                            "code_snippet": "c.fetchall()",
                            "line_number": "79",
                            "column_number": "22"
                        }
                    ],
                    "vulnerabilities": []
                },
                {
                    "name": "database_schema.py",
                    "structure": {
                        "other": "⋮...\n│def create_simple_schema(fields):\n⋮..."
                    },
                    "source": [],
                    "data_model": [],
                    "third_party_dependencies": [],
                    "sink_details": [],
                    "vulnerabilities": []
                }
            ]
        },
        {
            "name": "sqlite_rag.py",
            "structure": {
                "classes": [
                    {
                        "name": "SQLiteOpenAIRAG",
                        "class_body": "│class SQLiteOpenAIRAG:\n",
                        "methods": [
                            {
                                "name": "__init__",
                                "code": "│    def __init__(self, db_path: str = \n\"vector_store.db\"):\n│        load_dotenv()\n│        self.db_path = db_path\n│        # self._init_db()\n│        self.db_handler = DatabaseHandler(db_path)\n│        self.db_handler._init_db()\n│        self.async_client = AsyncOpenAI(\n│            api_key=os.getenv(\"OPENAI_API_KEY\"),\n│            timeout=60.0,\n│            max_retries=3\n⋮...\n"
                            },
                            {
                                "name": "format_chunks_to_xml",
                                "code": "│    def format_chunks_to_xml(self, chunks: List[Dict])\n-> str:\n⋮...\n│    async def extract_field_value(self, field: str, \nchunks: List[Dict], doc_type: str = \"MSA\") -> D\n⋮...\n│    async def process_field(self, field: str, \ndoc_type: str = \"MSA\") -> Dict[str, Any]:\n⋮...\n│    async def extract_all_fields(self, doc_type: str =\n\"MSA\") -> List[Dict[str, Any]]:\n⋮...\n│async def main():\n⋮...\n"
                            }
                        ]
                    }
                ],
                "other": "⋮..."
            },
            "source": [],
            "data_model": [],
            "third_party_dependencies": [],
            "sink_details": [
                {
                    "ai_sink_label": "API for OpenAI",
                    "code_summary": "The code initializes an asynchronous connection to the OpenAI API using an API key retrieved from environment variables, with specified timeout and retry settings.",
                    "code_snippet": "AsyncOpenAI(api_key = os.getenv(\"OPENAI_API_KEY\"), timeout = 60.0, max_retries = 3)",
                    "line_number": "52",
                    "column_number": "29"
                },
                {
                    "ai_sink_label": "SQLite",
                    "code_summary": "The code snippet is obtaining a cursor object from the SQLite connection, which is typically used to execute SQL queries and interact with the database.",
                    "code_snippet": "conn.cursor()",
                    "line_number": "303",
                    "column_number": "9"
                }
            ],
            "vulnerabilities": [
                {
                    "code_snippet": "Security Report ===================================== Rules: https://docs.bearer.com/reference/rules [v0.47.1] Language  Default Rules  Custom Rules  Files Python    88             0             4 CRITICAL: Unsanitized external input in code generation [CWE-94] 104                 schema = globals()[schema_name] ===================================== 88 checks, 1 findings CRITICAL: 1 (CWE-94)",
                    "line_number": "104",
                    "risk_level": "HIGH",
                    "ref_link": "https://docs.bearer.com/reference/rules/python_lang_code_injection",
                    "message_to_fix": "bearer ignore add 9fa4629e07eef6c9eb4f849b9d87265b_0"
                }
            ]
        }
    ]
}